# -*- coding: utf-8 -*-
"""readmapping.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CLEm--EZZ7gB57tHY1-zV1mke73slDSl
"""

from collections import defaultdict
import pandas as pd
import numpy as np
import io
import re
import difflib
import pdb
import argparse

parser = argparse.ArgumentParser(description='Process reference and donor files.')
parser.add_argument('reference_file', type=str, help='path to reference file')
parser.add_argument('donor_file', type=str, help='path to donor file')

args = parser.parse_args()

reference_file = args.reference_file
donor_file = args.donor_file

#reference_file = "/content/project1a_10000_reference_genome.fasta"
# Open the reference file and extract the DNA sequence
with open(reference_file) as f:
    # Read the file
    lines = f.readlines()
    # Remove newlines and any leading/trailing spaces
    lines = [line.strip() for line in lines]
    # Concatenate the DNA sequence lines
    reference_genome = "".join(lines[1:])

#define kmer_size and hamming dist
kmer_size = 16
hamming_distance = 1

# Print the output in the desired format
output_file = 'predictions.txt'

#function to calculate hamming distance
def HammingDistance(seq1, seq2):
    return len([i for i in range(len(seq1)) if seq1[i] != seq2[i]])


#function to generate kmers
def generate_reference_kmers(reference_genome, kmer_size):
    reference_kmers = {}
    for i in range(len(reference_genome) - kmer_size + 1):
        kmer = reference_genome[i:i+kmer_size]
        if kmer in reference_kmers:
            reference_kmers[kmer].append(i)
        else:
            reference_kmers[kmer] = [i]
    return reference_kmers

#function to align reads
def find_donor_matches(reference_genome, reference_kmers, donor_file, kmer_size, hamming_distance):
    donor_matches = {}
    # Open the donor file and read it line by line
    with open(donor_file, 'r') as f:
        donor_id = None
        donor_read = ""
        seq_len = 0
        for line in f:
            # Check if the line is a header line
            if line.startswith(">"):
                # Extract the read ID from the header
                donor_id = line.strip()[1:]
                # Initialize the read sequence string
                donor_read = ""
            else:
                # Concatenate the read sequence lines
                donor_read += line.strip()
                # Record the read sequence and its length
                seq_len = len(donor_read)
                donor_matches[donor_id] = {"seq": donor_read, "len": seq_len}

                # Generate all k-mers for the donor read
                donor_kmers = [donor_read[i:i+kmer_size] for i in range(len(donor_read) - kmer_size + 1)]

                # Find the best match position and score for each k-mer using a sliding window approach keep the read with the best hamming dist
                best_match_pos = None
                best_match_score = float('inf')
                for kmer in donor_kmers:
                    for i in range(len(reference_genome) - kmer_size + 1):
                        window = reference_genome[i:i+kmer_size]
                        if HammingDistance(window, kmer) <= hamming_distance:
                            hamming_dist = HammingDistance(reference_genome[i:i+len(donor_read)], donor_read)
                            if hamming_dist < best_match_score:
                                best_match_pos = i
                                best_match_score = hamming_dist

                if best_match_pos is not None:
                    if donor_id not in donor_matches:
                        donor_matches[donor_id] = {'matches': [], 'best_match_score': best_match_score}
                    donor_matches[donor_id]['matches'] = [best_match_pos]
                    donor_matches[donor_id]['best_match_score'] = best_match_score
    
    return donor_matches





#function to find substitutions
def find_subs(reference_genome, donor_matches):
    substitutions = []
    for read_id, read_info in donor_matches.items():
    #discard low quality reads with a hamming distance of less than 3
        if 'best_match_score' in read_info and read_info['best_match_score'] <= 3:
            read_seq = read_info['seq']
            for read_pos in read_info['matches']:
                for i in range(len(read_seq)):
                    if read_pos + i >= len(reference_genome):
                        break  # end of genome sequence reached
                        #Sliding window to check substitutions
                    if read_seq[i] != reference_genome[read_pos + i]:
                        substitution = {
                            'read_id': read_id,
                            'read_pos': read_pos + i,
                            'ref_nucleotide': reference_genome[read_pos + i],
                            'donor_nucleotide': read_seq[i]
                        }
                        substitutions.append(substitution)
    return substitutions


#function to get read counts of each substitution for coverage, and gets rid of erroroneous reads
def get_base_counts(substitutions, ratio_threshold):
    base_counts = {}
    for sub in substitutions:
        if sub['read_pos'] not in base_counts:
            base_counts[sub['read_pos']] = {'A': 0, 'C': 0, 'G': 0, 'T': 0, 'total': 0}
        base_count = base_counts[sub['read_pos']]
        base_count[sub['donor_nucleotide']] += 1
        base_count['total'] += 1

    # Filter out positions with total base count of two or less
    base_counts = {pos: counts for pos, counts in base_counts.items() if counts['total'] > 2}

    # Filter out reads that don't qualify for the threshold
    for pos, counts in base_counts.items():
        total_count = counts['total']
        min_count = total_count * ratio_threshold
        counts = {base: count for base, count in counts.items() if base != 'total' and count >= min_count}
        base_counts[pos] = counts

    return base_counts

#print out subs
def print_base_substitutions(ref_genome, base_counts, output_file):
    with open(output_file, 'w') as f:
        for pos, counts in base_counts.items():
            ref_base = ref_genome[pos]
            for base, count in counts.items():
                if base != 'total' and count > 0:
                    f.write(f">S{pos} {ref_base} {base}\n")



#calculating the distance between each first and last L/3
def calculate_distance(pos1, pos2, kmer_size, indels, read):
    """
    Calculate the distance between two positions in the reference genome.
    """
    for p1 in pos1:
        for p2 in pos2:
            distance = abs(p2 - p1)
            #detect deletion
            if distance == (2 * kmer_size + 1):
                if read not in indels:
                    indels[read] = []
                indels[read].append(('deletion', p1 + 16))  # Append pos1 + 16 to indels[read]
            #detect insertion
            elif distance == (2 * kmer_size - 1):
                if read not in indels:
                    indels[read] = []
                indels[read].append(('insertion', p1 + 16))  # Append pos1 + 16 to indels[read]
    return

#function to break read into L/3 and check for for deletions and insertions
def find_indels(donor_matches, reference_kmers, kmer_size):
    indels = {}  # Initialize an empty dictionary for storing indels
    for donor_id, donor_info in donor_matches.items():
        donor_read = donor_info['seq']
        read = donor_id
        seq_len = donor_info['len']

        if seq_len != 50:
          continue 

        substring1 = donor_read[0:16]
        substring2 = donor_read[16:32]
        substring3 = donor_read[32:48]
  
        
        if substring1 in reference_kmers:
            pos1 = reference_kmers[substring1]
        else:
            continue
            
        if substring3 in reference_kmers:
            pos3 = reference_kmers[substring3]
        else:
            continue

        calculate_distance(pos1, pos3, kmer_size, indels, read)  # Pass kmer_size, indels, and read to calculate_distance

    return indels


#compare indel list with reference genome 
def check_true_indel(reference_genome, donor_matches, indels, kmer_size):
    true_indels = {}

    for read, indel_list in indels.items():
        don_seq = donor_matches[read]['seq']
        don_sub = don_seq[kmer_size : 2*kmer_size]

        for indel in indel_list:
            indel_type, pos = indel
            ref_pos = pos  # Calculate the position in the reference genome
            ref_sub = reference_genome[ref_pos : ref_pos + kmer_size]

            # Compare two strings for insertion and deletetion
            diff = difflib.ndiff(ref_sub, don_sub)

            count = 0

            for idx, line in enumerate(diff):
                if indel_type == "deletion":
                    if line.startswith('-'):
                        count += 1
                elif indel_type == "insertion":      
                    if line.startswith('+'):
                        count += 1

            if count == 1:
                diff_copy = difflib.ndiff(ref_sub, don_sub)  # Create a copy of diff
                for idx, line in enumerate(diff_copy):
                    if indel_type == "deletion":
                        if line.startswith('-'):
                            position = idx  # Calculate the position in the second string
                            true_indels.setdefault(read, []).append(('D', position + ref_pos - 1, line[1:]))
                    elif indel_type == "insertion":
                        if line.startswith('+'):
                            position = idx  # Calculate the position in the second string
                            true_indels.setdefault(read, []).append(('I', position + ref_pos - 1, line[2:]))

    return true_indels

#print out indels
def print_true_indels(true_indels, output_file):
    with open(output_file, 'a') as f:
        for read, indel_data in true_indels.items():
            for indel_type, pos, value in indel_data:
                f.write(f">{indel_type}{pos} {value.strip()}\n")


#calling functions
reference_kmers = generate_reference_kmers(reference_genome, kmer_size)

donor_matches = find_donor_matches(reference_genome, reference_kmers, donor_file, kmer_size, hamming_distance)

subs = find_subs(reference_genome, donor_matches)

#set threshold to 0.80 to filter out errors
counts = get_base_counts(subs, 0.80)

print_base_substitutions(reference_genome, counts, output_file)

indels = find_indels(donor_matches, reference_kmers, kmer_size)

# Call the function and get the true indels dictionary
true_indels = check_true_indel(reference_genome, donor_matches, indels, kmer_size)

print_true_indels(true_indels, output_file)

